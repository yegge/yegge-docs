# Music Catalog Discography - Complete Setup Documentation

## Project Overview

This is a music catalog and discography management application built with React, TypeScript, Tailwind CSS, and Lovable Cloud (Supabase backend). It allows for managing albums, tracks, and associated metadata with proper authentication and role-based access control.

**Key Features:**
- Album and track catalog management
- Admin-only content management system
- Public-facing discography display
- File storage for album artwork
- Role-based access control (RBAC)
- Bootstrap admin functionality for initial setup

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Initial Setup](#initial-setup)
3. [Database Configuration](#database-configuration)
4. [Authentication Setup](#authentication-setup)
5. [Storage Configuration](#storage-configuration)
6. [Bootstrap Admin User](#bootstrap-admin-user)
7. [Common Pitfalls & Solutions](#common-pitfalls--solutions)
8. [Development Workflow](#development-workflow)
9. [Deployment](#deployment)
10. [Maintenance](#maintenance)

---

## Prerequisites

Before starting, ensure you have:

- **Node.js** (v18 or higher) - [Install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)
- **npm** (comes with Node.js)
- **Git** for version control
- **Lovable Cloud** enabled on your project (provides Supabase backend automatically)

---

## Initial Setup

### 1. Clone and Install

```bash
# Clone the repository
git clone <YOUR_GIT_URL>

# Navigate to project directory
cd <YOUR_PROJECT_NAME>

# Install dependencies
npm install

# Start development server
npm run dev
```

The application will be available at `http://localhost:8080`

### 2. Environment Variables

**CRITICAL: DO NOT manually edit the `.env` file!**

The `.env` file is auto-generated by Lovable Cloud and contains:
- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_PUBLISHABLE_KEY`
- `VITE_SUPABASE_PROJECT_ID`

These are automatically configured and updated by the Supabase integration.

---

## Database Configuration

### Database Schema Overview

The application uses three main tables:

1. **albums** - Stores album information
2. **tracks** - Stores track information
3. **user_roles** - Manages user permissions (RBAC)

### Custom Types (Enums)

The following custom PostgreSQL enums are used:

```sql
-- Role types
CREATE TYPE app_role AS ENUM ('admin', 'moderator', 'user');

-- Album status
CREATE TYPE album_status AS ENUM ('In Development', 'Released', 'Removed');

-- Track status
CREATE TYPE track_status AS ENUM ('WIP', 'RELEASED');

-- Production stages
CREATE TYPE production_stage AS ENUM (
  'CONCEPTION',
  'RECORDING',
  'MIXING',
  'MASTERING',
  'RELEASED'
);

-- Visibility levels
CREATE TYPE visibility_level AS ENUM ('Public', 'Private');
```

### Database Functions

**IMPORTANT:** The project includes several critical database functions:

#### 1. `has_role()` - Security Definer Function

```sql
CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role app_role)
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id AND role = _role
  )
$function$
```

**Purpose:** Checks if a user has a specific role. Uses `SECURITY DEFINER` to avoid recursive RLS policy issues.

#### 2. `auto_release_tracks()` - Trigger Function

Automatically updates all tracks to "RELEASED" status when an album is marked as "Released".

#### 3. `update_album_duration()` - Trigger Function

Calculates and updates album duration based on the sum of all track durations.

#### 4. `update_updated_at_column()` - Trigger Function

Automatically updates the `updated_at` timestamp on row modifications.

### Row-Level Security (RLS) Policies

**CRITICAL SECURITY REQUIREMENT:** All tables MUST have RLS enabled.

#### Albums Table RLS

```sql
-- Public can view released albums with released tracks
CREATE POLICY "Public can view albums with released tracks"
ON albums FOR SELECT
USING (
  visibility = 'Public'::visibility_level
  AND status IN ('Released'::album_status, 'Removed'::album_status)
  AND (
    NOT EXISTS (SELECT 1 FROM tracks WHERE album_id = albums.id)
    OR NOT EXISTS (
      SELECT 1 FROM tracks
      WHERE album_id = albums.id
      AND stage_of_production <> 'RELEASED'::production_stage
    )
  )
);

-- Admins can manage all albums
CREATE POLICY "Admins can view all albums" ON albums FOR SELECT USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can insert albums" ON albums FOR INSERT WITH CHECK (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can update albums" ON albums FOR UPDATE USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can delete albums" ON albums FOR DELETE USING (has_role(auth.uid(), 'admin'));
```

#### Tracks Table RLS

```sql
-- Public can view released tracks
CREATE POLICY "Public can view released tracks"
ON tracks FOR SELECT
USING (
  visibility = 'Public'::visibility_level
  AND stage_of_production = 'RELEASED'::production_stage
);

-- Admins can manage all tracks
CREATE POLICY "Admins can view all tracks" ON tracks FOR SELECT USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can insert tracks" ON tracks FOR INSERT WITH CHECK (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can update tracks" ON tracks FOR UPDATE USING (has_role(auth.uid(), 'admin'));
CREATE POLICY "Admins can delete tracks" ON tracks FOR DELETE USING (has_role(auth.uid(), 'admin'));
```

#### User Roles Table RLS

```sql
-- Users can view their own roles
CREATE POLICY "Users can view their own roles"
ON user_roles FOR SELECT
USING (auth.uid() = user_id);

-- Admins can manage all roles
CREATE POLICY "Admins can manage all roles"
ON user_roles FOR ALL
USING (has_role(auth.uid(), 'admin'))
WITH CHECK (has_role(auth.uid(), 'admin'));

-- Bootstrap first admin (critical for initial setup)
CREATE POLICY "Bootstrap first admin"
ON user_roles FOR INSERT
WITH CHECK (
  auth.uid() = user_id
  AND role = 'admin'::app_role
  AND NOT EXISTS (SELECT 1 FROM user_roles WHERE role = 'admin'::app_role)
);
```

---

## Authentication Setup

### Enable Auto-Confirm Email Signups

**CRITICAL:** For development and non-production environments, enable auto-confirm email signups to avoid email verification issues.

This should be configured via Lovable Cloud authentication settings:
- `auto_confirm_email`: `true`
- `disable_signup`: `false`
- `external_anonymous_users_enabled`: `false`

### Authentication Flow

1. Users sign up via the `/auth` route
2. Email is auto-confirmed (in development)
3. User is redirected to home page
4. To access admin features, user must be granted admin role

---

## Storage Configuration

### Storage Bucket: `artwork`

**Configuration:**
- Bucket Name: `artwork`
- Public Access: `Yes` (required for displaying album artwork publicly)

**RLS Policies for Storage:**

While the bucket is public for reading, you should still implement proper upload policies:

```sql
-- Allow authenticated users to upload
CREATE POLICY "Authenticated users can upload artwork"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'artwork');

-- Allow public to view
CREATE POLICY "Public can view artwork"
ON storage.objects FOR SELECT
USING (bucket_id = 'artwork');
```

---

## Bootstrap Admin User

### The Bootstrap Process

**IMPORTANT:** This is a ONE-TIME operation that creates the first admin user.

#### Step 1: Sign Up

1. Navigate to `/auth`
2. Create a new account (this will be your admin account)
3. Sign in with the credentials

#### Step 2: Bootstrap Admin Role

1. Navigate to `/bootstrap-admin`
2. Click the "Bootstrap Admin" button
3. This inserts an admin role for your user via the special RLS policy

**Technical Details:**

The `BootstrapAdmin.tsx` component uses this special RLS policy:

```sql
CREATE POLICY "Bootstrap first admin"
ON user_roles FOR INSERT
WITH CHECK (
  auth.uid() = user_id
  AND role = 'admin'::app_role
  AND NOT EXISTS (SELECT 1 FROM user_roles WHERE role = 'admin'::app_role)
);
```

This policy allows the first user to grant themselves admin privileges ONLY if no admin exists.

#### Step 3: Verify Admin Access

After bootstrapping:
1. Refresh the page
2. Navigate to `/admin`
3. You should now have access to the admin panel

### Adding Additional Admins

Once the first admin is created, additional admins can only be added by:
1. Existing admin users through the admin panel (if you build this feature)
2. Direct database insertion by the first admin

---

## Common Pitfalls & Solutions

### 1. **Recursive RLS Policy Errors**

**Problem:** RLS policies that check roles can cause infinite recursion.

**Solution:** Always use the `has_role()` function with `SECURITY DEFINER` instead of direct queries in RLS policies.

❌ **WRONG:**
```sql
CREATE POLICY "Admins only"
USING (
  EXISTS (SELECT 1 FROM user_roles WHERE user_id = auth.uid() AND role = 'admin')
);
```

✅ **CORRECT:**
```sql
CREATE POLICY "Admins only"
USING (has_role(auth.uid(), 'admin'));
```

### 2. **Foreign Key to auth.users**

**Problem:** You cannot query `auth.users` table directly from client-side code.

**Solution:** 
- DO NOT create foreign keys to `auth.users` if you need to join user data
- Create a `profiles` table in the `public` schema instead
- Link profiles to `auth.users.id` but query the profiles table

### 3. **Storage Bucket Not Public**

**Problem:** Album artwork doesn't display because storage bucket is private.

**Solution:** Ensure the `artwork` bucket has `public: true` in its configuration.

### 4. **Auto-Confirm Email Not Enabled**

**Problem:** Users can't sign in because email verification is required but not working.

**Solution:** Enable auto-confirm email signups for development environments.

### 5. **Missing Bootstrap Admin Route**

**Problem:** Cannot create the first admin user.

**Solution:** Ensure the `/bootstrap-admin` route exists and is accessible before authentication.

### 6. **RLS Policies Too Restrictive**

**Problem:** Admin users can't see any data after logging in.

**Solution:** Verify RLS policies use `has_role()` correctly and admin role exists in `user_roles` table.

### 7. **Hardcoded Credentials or Client-Side Role Checks**

**Problem:** Security vulnerability - roles checked via localStorage or hardcoded credentials.

**Solution:** ALWAYS check roles server-side using RLS policies and the `has_role()` function.

### 8. **Modifying Auto-Generated Files**

**Problem:** Changes to auto-generated files get overwritten.

**Solution:** NEVER edit these files:
- `src/integrations/supabase/client.ts`
- `src/integrations/supabase/types.ts`
- `.env`
- `supabase/config.toml`

### 9. **Using CHECK Constraints for Time-Based Validations**

**Problem:** CHECK constraints must be immutable in PostgreSQL, causing issues with time-based checks.

**Solution:** Use validation triggers instead of CHECK constraints for validations like `expire_at > now()`.

### 10. **Null/Undefined Handling in TypeScript**

**Problem:** Runtime errors due to accessing properties on null/undefined values.

**Solution:** Always check for null/undefined before accessing nested properties:
```typescript
const artwork = album?.artwork_front || '/placeholder.svg';
```

---

## Development Workflow

### File Structure

```
src/
├── components/
│   ├── admin/           # Admin-only components
│   │   ├── AlbumForm.tsx
│   │   ├── AlbumList.tsx
│   │   ├── TrackForm.tsx
│   │   └── TrackList.tsx
│   ├── ui/              # shadcn/ui components
│   ├── AlbumCard.tsx    # Public album display
│   ├── AlbumDetail.tsx  # Album detail modal
│   └── BootstrapAdmin.tsx
├── pages/
│   ├── Admin.tsx        # Admin panel
│   ├── Auth.tsx         # Authentication page
│   ├── Index.tsx        # Public homepage
│   └── NotFound.tsx
├── lib/
│   ├── auth.ts          # Auth utilities
│   ├── logger.ts        # Logging utilities
│   ├── utils.ts         # General utilities
│   └── validation.ts    # Form validation
├── integrations/
│   └── supabase/        # Auto-generated (DO NOT EDIT)
└── index.css            # Design system tokens
```

### Design System

**CRITICAL:** Always use semantic tokens from `index.css` and `tailwind.config.ts`.

❌ **WRONG:**
```tsx
<div className="text-white bg-black">
```

✅ **CORRECT:**
```tsx
<div className="text-foreground bg-background">
```

All colors MUST be in HSL format and defined as CSS variables.

### Adding New Features

1. **Database Changes:** Use Lovable's database migration tool
2. **UI Components:** Create focused, reusable components
3. **Authentication:** Always check auth state with `supabase.auth.getUser()`
4. **Roles:** Use RLS policies with `has_role()` function
5. **Forms:** Use `react-hook-form` with `zod` validation

---

## Deployment

### Via Lovable

1. Click the **Publish** button in the top right of the Lovable editor
2. Your app will be deployed automatically
3. Access via the provided `yoursite.lovable.app` URL

### Custom Domain

1. Navigate to **Project > Settings > Domains**
2. Click **Connect Domain**
3. Follow the DNS configuration instructions
4. Note: Requires a paid Lovable plan

### Manual Deployment

If deploying outside of Lovable:

```bash
# Build for production
npm run build

# The dist/ folder contains your static files
# Deploy to any static hosting service (Vercel, Netlify, etc.)
```

**IMPORTANT:** Ensure environment variables are configured in your hosting platform:
- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_PUBLISHABLE_KEY`
- `VITE_SUPABASE_PROJECT_ID`

---

## Maintenance

### Database Backups

Lovable Cloud (Supabase) automatically handles database backups. You can access backup management through the backend dashboard.

### Monitoring

1. **Console Logs:** Check browser console for frontend errors
2. **Network Requests:** Monitor API calls in browser DevTools
3. **Backend Logs:** Access through Lovable Cloud backend dashboard

### Updating Dependencies

```bash
# Check for outdated packages
npm outdated

# Update packages (use Lovable tools, not manual package.json edits)
# Use the AI to update dependencies via lov-add-dependency tool
```

### Security Audits

Run periodic security checks:

```bash
# Check for vulnerabilities
npm audit

# Fix vulnerabilities
npm audit fix
```

### Database Linting

Use Lovable's Supabase linter tool to check for:
- Missing RLS policies
- Security misconfigurations
- Performance issues

**IMPORTANT:** The linter only catches obvious issues. Always manually review:
- RLS policy logic
- Auth flows
- Sensitive data exposure

---

## Troubleshooting

### "Cannot read property of undefined"

**Cause:** Accessing nested properties without null checks.

**Solution:**
```typescript
// Use optional chaining
const name = album?.album_name ?? 'Unknown';
```

### "Permission denied for table"

**Cause:** Missing or incorrect RLS policies.

**Solution:**
1. Verify RLS is enabled: `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;`
2. Check policies cover the operation (SELECT, INSERT, UPDATE, DELETE)
3. Ensure user has correct role in `user_roles` table

### "Function has_role does not exist"

**Cause:** Database function not created or wrong schema.

**Solution:**
1. Ensure function is created with `SECURITY DEFINER`
2. Set `search_path = public` in function definition
3. Re-run database migration

### Bootstrap Admin Not Working

**Cause:** Admin already exists or policy not configured.

**Solution:**
1. Check if admin exists: `SELECT * FROM user_roles WHERE role = 'admin';`
2. If admin exists but it's not you, contact the admin
3. Verify bootstrap policy exists in `user_roles` table

### Images Not Displaying

**Cause:** Storage bucket not public or incorrect URL.

**Solution:**
1. Verify `artwork` bucket is public
2. Check storage URL format: `${supabaseUrl}/storage/v1/object/public/artwork/${filename}`
3. Verify file was uploaded successfully

---

## Additional Resources

- [Lovable Documentation](https://docs.lovable.dev/)
- [Supabase Documentation](https://supabase.com/docs)
- [React Documentation](https://react.dev/)
- [Tailwind CSS Documentation](https://tailwindcss.com/)
- [shadcn/ui Documentation](https://ui.shadcn.com/)

---

## Quick Reference Commands

```bash
# Start development server
npm run dev

# Build for production
npm run build

# Preview production build
npm run preview

# Type checking
npx tsc --noEmit

# Linting
npm run lint
```

---

## Final Notes

1. **Security First:** Always use RLS policies and server-side validation
2. **Never Hardcode:** Use environment variables and secure secrets management
3. **Test Thoroughly:** Test all CRUD operations with different user roles
4. **Document Changes:** Keep this documentation updated when making significant changes
5. **Backup Regularly:** Ensure database backups are configured
6. **Monitor Performance:** Keep an eye on query performance and optimize as needed

---

**Version:** 1.0  
**Last Updated:** 2025-10-06  
**Project:** Music Catalog Discography  

---

## License & Credits

This project uses:
- React (MIT License)
- Vite (MIT License)
- Tailwind CSS (MIT License)
- shadcn/ui (MIT License)
- Supabase (Apache 2.0 License)

For questions or issues, refer to the [Lovable Discord Community](https://discord.com/channels/1119885301872070706/1280461670979993613).
